# Примеры синхронизации потоков

## Организация параллельного выполнения потоков без использования средств синхронизации
Файл `ex1.cpp`. Для компиляции примера необходимо выполнить в консоли команду `g++ ex1.cpp -lpthread` (для этого потребуется компилятор GCC с установленой утилитой g++). Если компиляция прошла успешно, для запуска скомпилированного приложения необходимо выполнить команду `./a.out`. На большинстве систем программа продемонстрирует параллельное выполнение потоков и выведет в консоль что-то похожее на
```
Thread 3
Thread 2
Thread 1
Thread 3
Thread 2
Thread 3
Thread 1
Thread 2
Thread 1
```

Если по каким-то причинам потоки выполнились последовательно, следует увеличить в несколько раз значение задержки, используемое при вызове функции `sleep_ms()` в теле функции `thread()`. В общем случае задержка в миллисекундах должна подбираться индивидуально для каждой вычислительной машины, на которой запускается программа, т.к. она зависит от частоты центрального процессора, доступного объема оперативной памяти, операционной системы, количества запущенных в данный момент процессов, объема выделенных виртуальной машине ресурсов (если используется виртуальная машина) и других параметров. В подавляющем большинстве случаев задержки в 50-100 миллисекунд должно быть достаточно, для некоторых современных персональных компьютеров достаточной задержкой будет являться и 1 миллисекунда. Установка слишком большой задержки приведет к простаиванию всех потоков процесса и длительному времени выполнения программы.

Параллельное выполнение потоков происходит по следующей причине. Когда один из потоков переходит в состояние ожидания после вызова функции для приостановки его выполнения на заданное число миллисекунд, планировщик задач передает управление другому потоку, который практически сразу так же переходит в состояние ожидания прерывания таймера, и т.д. В итоге, если время задержки выполнения потоков не на столько мало, чтобы планировщик счел нецелесообразным переключаться на другой поток, будет имитироваться параллельное выполнение потоков.

В коде примера вводится специальная функция `void sleep_ms(int milliseconds)`, выполняющая системный вызов для приостановки вызвавшего ее потока на заданное число миллисекунд. В действительности поток может быть приостановлен и на более длительное время, покольку планировщик задач может передать управление потоку не сразу после того, как истечет запрошенный временной интервал приостановки потока. В зависимости от поддерживаемой операционной системой версии стандарта POSIX, функция `sleep_ms()` вызывает либо системную функцию `int usleep(useconds_t usec)`, либо функцию `int nanosleep(const struct timespec *req, struct timespec *rem)`. Функция [`usleep()`](http://man7.org/linux/man-pages/man3/usleep.3.html) принимает на вход количество микросекунд, на которое должно быть приостановлено выполнение потока, в то время как [`nanosleep()`](http://man7.org/linux/man-pages/man2/nanosleep.2.html) позволяет задать время задержки с точностью до наносекунд. Функция `usleep()` объявлена устаревшей в стандарте POSIX.1-2001 и удалена из стандарта начиная с POSIX.1-2008. Вместо нее в этих стандартах введена функция `nanosleep()`. Тем не менее дистрибутивы Linux продолжают поддерживать функцию `usleep()` для обеспечения совместимости ранее написанного кода.

Также Linux поддерживает системную функцию [`sleep()`](http://man7.org/linux/man-pages/man3/sleep.3.html), осуществляющую задержку вызвашего ее потока на целое число **секунд**. Для рассматриваемой задачи синхронизации потоков использование такой большой задержки нецелесообразно. Следует отметить, что в ОС Windows также имеется функция [`Sleep()`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx), но она осуществляет приостановку вызвавшего ее потока на заданное число миллисекунд.

## Использование мьютекса для работы с общим ресурсом
Файл `ex2.cpp`. Для компиляции примера необходимо выполнить в консоли команду `g++ ex2.cpp -lpthread` (для этого потребуется компилятор GCC с установленой утилитой g++). Если компиляция прошла успешно, для запуска скомпилированного приложения необходимо выполнить команду `./a.out`. Программа демонстрирует различия при использовании мьютексов для защиты критической секции и без защиты критической секции. В данном случае в критической секции осуществляется работа с общим реурсом - консолью. На большинстве систем пример выведет в консоль что-то похожее на
```
Running threads without a mutex: pwHroeorlgllrdo a m
Now running them with a mutex: programworld Hello 
```
Изменить задержку можно с помощью целочисленное константы `sleep_time`, объявленной в начале файла.

Пример иллюстрирует необходимость использования критических секций для корректной работы с общим ресурсом. Сначала запускаются три потока, каждый из которых выводит в консоль свое слово. При этом каждая буква выводится с помощью отдельной команды `std::cout << character << std::flush;`. В современных операционных системах каждый вызов системной функции для осуществления операции ввода-вывода является атомарным в том смысле, что другой поток не может выполнить операцию ввода-вывода в отношении того же файла (или устройства), если первый поток уже начал выполнять операцию ввода-вывода. Большинство операционных систем гарантирует это (но не все!), т.к. подобное требование прописано в [стандарте](https://pubs.opengroup.org/onlinepubs/9699919799/functions/flockfile.html) POSIX. Поэтому, если в функциях `thread1` и `thread2` использовать `std::cout << thread_msg` для вывода сразу всего слова целиком, без дополнительного цикла `for (int i ...)`, переключения между потоками посередине операции вывода слова в консоль не произойдет и первая строчка не будет выглядеть как бессмысленная случайная последовательность символов. Тем не менее, следует учитывать, что функция `printf()` (и, соответственно, `std::cout`), может [не являться](https://stackoverflow.com/a/3941563) реентерабельной (reentrant), хотя большинство ее реализаций при этом являются потокобезопасными (thread-safe).

После завершения первых трех потоков, запускаются еще три потока, которые выполняют то же самое действие, но используют мьютекс для доступа к критической секции. Перед тем, как вывести в консоль следующее слово, поток захватывает мьютекс, после чего начинает выводить слово посимвольно в консоль. По завершении вывода слова в консоль поток освобождает мьютекс. Из кода видно, что даже использование принудительных задержек (приостановок выполнения потока) внутри критической секции не позволяет планировщику задач переключиться на выполнение другого потока, пока не будет освобожден мьютекс.

Операционная система использует буфер для операций вывода. Это значит, что операция `std::cout << "Hello, World!";` сначала приведет к записи строки `"Hello, World!"` в память, а не в файл или консоль. Затем, после нескольких операций вывода, когда буфер в памяти будет заполнен, операционная система запишет его содержимое в файл на диске или в консоль. Такой подход позволяет уменьшить количество дорогостоящих по времени операций записи и оптимизировать работу с внешними устройствами, которые обычно эффективнее работают с большими фрагментами данных, чем с несколькими байтами. Однако, буфер можно "очистить" принудительно, чтобы отправить хранящиеся в нем данные в файл или консоль немедленно. Для этого достаточно добавить `std::flush` следующим образом: `std::cout << "Hello, World!" << std::flush;`. В языке Си, в паре с функцией `printf()` для достижения аналогичного результата можно использовать функцию `fflush()`. Следует отметить, что при работе с текстовыми файлами и консолью операционная система обычно сама принудительно очищает буфер, записывая данные в файл или выводя их в консоль, если записываемая строка заканчивается символом перевода строки. Поэтому после команды `std::cout << "Hello, World!" << std::endl;` писать `std::flush` не нужно.

## Использование семафоров для синхронизации потоков
### Синхронизация на примере двух потоков
Рассмотрим еще один пример, см. файл `ex3.cpp`. В нем решается классическая задача [производителя-потребителя](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem) с использованием семафоров. Приведенное решение позволяет синхронизировать потоки, заставив их выполняться в нужном порядке. Для этого используются два семафора, один из которых, назовем его "семафор A", инициализируется нулевым начальным значением (т.е. первое обращение к нему приведет к блокировке потока), а второй, назовем его "семафор B", проинициализирован начальным значением 1. Первый поток выполняет операцию *down* в отношении семафора A, затем выполняет основную работу, после чего выполняет операцию *up* в отношении семафора B. Второй поток сначала выполняет операцию *down* в отношении семафора B, затем выполняет свою основную работу, после чего выполняет операцию *up* в отношении семафора A.

Рассмотрим по шагам, как работает код в этом примере. Обозначим потоки символами C и P, а семафоры символами A и B. Пусть оба потока созданы одновременно и других потоков в системе нет. Семафор A проинициализрован нулевым значением (имеет ноль отложенных активаций), а семафор B проинициализирован значением 1 (имеет одну отложенную активацию).
1. Если первым начинает выполняться поток C, то он сразу блокируется при вызове *down* в отношении семафора A, начальное значение которого равно нулю.
2. Начинает выполняться поток P, вызов операции *down* уменьшает значение семафора B до нуля.
3. Поток P выполняет свою работу и открывает семафор A, увеличивая его значение с помощью операции *up*.
4. При попытке выполнить следующую итерацию цикла внутри потока P он блокируется при вызове операции *down* в отношении семафора B, поскольку на шаге 2 значение этого семафора стало равно нулю.
5. Управление передается потоку C, который теперь может продолжить свою работу, поскольку на шаге 3 счетчик семафора A стал больше нуля.
6. Значение семафора A уменьшается потоком C на единицу операцией *down* и поток C продолжает выполняться.
7. Поток C завершает выполнение итерации своего цикла и открывает семафор B, увеличивая его значение с помощью операции *up*.
8. При попытке выполнить следующую итерацию цикла внутри потока C он блокируется при вызове операции *down* в отношении семафора A, поскольку на шаге 6 значение этого семафора стало равно нулю.
9. Управление передается потоку P, который теперь может продолжить свою работу, поскольку на шаге 7 счетчик семафора B стал больше нуля.
10. Работа алгоритма продолжается с шага 2.

В качестве эксперимента рекомендуется попробовать запустить несколько потоков каждого типа (P и C). При этом следует помнить, что суммарное количество итераций цикла во всех потоках типа P должно быть равно суммарному количеству итераций цикла во всех потоках типа C. В случае невыполнения этого условия процесс не сможет завершиться, т.к. один или несколько потоков окажутся навсегда заблокированными в ожидании семафора. В коде предусмотрены константы `NUMBER_OF_C_THREADS` и `NUMBER_OF_P_THREADS` для управления количеством потоков каждого типа. Если значения этих констант не будут одинаковыми, для соблюдения вышеописанного условия следует изменить количество итераций цикла внутри одного из потоков, чтобы выполнялось условие  
`NUMBER_OF_C_THREADS * <количество_итераций_в_потоке_C> = NUMBER_OF_P_THREADS * <количество_итераций_в_потоке_P>`.

Также в качестве дополнительного упражнения может быть рассмотрен случай с числом семафоров и количеством типов потоков большим 2.

### Особенности реализации семафоров
В ОС Linux в соответствии со стандартом POSIX есть два вида семафоров: **именованные** (named) и **неименованные** (unnamed). 

Именованный семафор имеет привязанный к нему строковый идентификатор на подобие имени файла. По аналогии с файлами, создается такой семафор функцией `sem_open()` с флагом `O_CREAT`, а при завершении использования именованного семафора необходимо вызвать функцию `sem_close()`. Как и функция `close()` при работе с файлами, `sem_close()` не удаляет семафор, а лишь сообщает операционной системе, что данный процесс больше работать с этим семафором не будет. При этом семафор остается в виде файла в виртуальной файловой системе и при следующем запуске программы будет использован повторно. В частности, если именованный семафор не был удален, то, при вызове `sem_open()` с флагом `O_CREAT` при следующем запуске программы, будет открыт (не создан!) "старый" семафор с указанным именем, а попытка проинициализировать его нужным начальным значением не сработает. Вместо этого семафор будет иметь значение, которое у него было на момент завершения предыдущего запуска программы. Для окончательного удаления именованного семафора необходимо использовать функцию `sem_unlink()`. Здесь продолжается аналогия с файлами, поскольку функция `unlink()` используется для удаления пути (директории или файла) из файловой системы. Таким образом, при работе с именованными семафорами важно не забывать удалять их после того, как они становятся не нужны.

Важной особенностью именованных семафоров является возможность работы с одним семафором сразу нескольких процессов. Для этого при создании семафора должны быть указаны соответствующие права доступа, а другие процессы могут использовать семафор указав его имя при вызове функции `sem_open()`. В этом смысле именованный семафор является полноценным средством межпроцессного взаимодействия, хотя может использоваться и взаимодействующими потоками в рамках одного единственного процесса.

Неименованный семафор создается в памяти и не имеет привязки к файловой системе. Если такой семафор расположен в общей (разделяемой) памяти (shared memory), он будет доступен всем процессам, имеющим доступ к общей памяти. В простейшем же случае неименованный семафор создается в локальной памяти процесса и доступен только потокам этого процесса. Создается неименованный семафор функцией `sem_init()`, имеющей сигнатуру `int sem_init(sem_t *sem, int pshared, unsigned int value);`. Первый параметр, `sem_t *sem`, должен быть указателем на описывающую семафор переменную типа `sem_t`, в которую функция запишет сведения о созданном семафоре. Второй параметр, `int pshared`, является файловым идентификатором, возвращаемым функцией `shm_open` при создании области общей памяти. В случае, если неименованный семафор будет использоваться только потоками внутри одного процесса, значение параметра `pshared` должно быть равно нулю. Третий параметр, `unsigned int value`, позволяет задать начальное значение семафора, т.е. проиницилизировать его. Функция `sem_init()` возвращает ноль, если неименованный семафор был создан успешно, и -1, если произошла ошибка. После завершения работы с неименованным семафором его следует удалить с помощью функции `sem_destroy()`.

Следует отметить, что в MacOS реализованы только именованные семафоры. Функции `sem_init()` и `sem_destroy()` в этой операционной системе есть, но всегда возвращают код ошибки, соответствующий значению "not implemented". 

Для работы с именованными и неименованными семафорами используются одни и те же функции `sem_wait()` и `sem_post()`. Первая уменьшает счетчик семафора на единицу, если на момент вызова его значение больше нуля, или блокирует выполнение вызвавшего ее потока, если счетчик семафора равен нулю. Вторая увеличивает счетчик семафора на единицу.

